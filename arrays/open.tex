\section{Open issues}

In this section we discuss open issues that need to be solved regarding this proposal.

\subsection{Size determination}

The current proposal implies that the size of any \emph{run-time bound array
data member} can be derived from the environment where the inline constructor is
defined.

In particular, this proposal does not allow the following example (slightly
modified from an example provided by Lawrence Crowl.

\begin{lstlisting}
// a.h
struct A {
  bs_array<double> storage;
  A(int n);
};

// a.cc
  extern int config;
  A::A(int n) : storage(n*config) {}
\end{lstlisting}

As \emph{struct A} has a data member which is a \emph{run-time size bound class}
(the \verb+bs_array+), it is considered itself to be also a \emph{run-time size
bound class} and the same restrictions apply to it. Thus it needs that its
constructor is defined inline.

In this proposal we have not addressed this problem. We think it should be first
clarified if this use case is important enough to be solved.

Possible solutions are:

\begin{itemize}

\item Require that the variable (i.e. \verb+config+) is visible in the point of definition of the
inline constructor.

\item Modify the proposal so that it is not required that the constructor is
defined inline.

\end{itemize}

\subsection{Multi-dimensional data members}

This proposal initially tries to support single-dimension \emph{run-time bound}
data members. However, if needed it could be extended to support multiple
dimension \emph{run-time bound} data members.

\begin{lstlisting}
class stack_matrix {
public:
  stack_matrix(int r, int c) : v[r][c]{} {}
  // ...
private:
  double[][] v;
};
\end{lstlisting}

